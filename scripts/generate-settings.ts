// Copyright (C) 2026 Langning Chen
//
// This file is part of cph-ng.
//
// cph-ng is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// cph-ng is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with cph-ng.  If not, see <https://www.gnu.org/licenses/>.

import { writeFileSync } from 'node:fs';
import pkg from '../package.json';

type ContributionProps =
  | { type: 'string'; default: string; enum?: string[] }
  | { type: 'number'; default: number; enum?: number[] }
  | { type: 'boolean'; default: boolean }
  | { type: 'array'; default: string[]; items: { type: 'string'; enum: string[] } };

interface SectionProp {
  key: string;
  shortKey: string;
  type: string;
  defaultValue: unknown;
}

interface Section {
  name: string;
  className: string;
  props: SectionProp[];
}

const Paths = {
  adapter: 'src/infrastructure/vscode/settingsAdapter.ts',
  interface: 'src/application/ports/vscode/ISettings.ts',
  mock: 'tests/infrastructure/vscode/settingsMock.ts',
};

const header = [
  `// THIS FILE IS AUTO-GENERATED BY scripts/generate-settings.js`,
  `// DO NOT EDIT THIS FILE MANUALLY`,
].join('\n');

const AdapterBaseClass = `
class SettingsSectionBase {
  public constructor(
    protected readonly section: string,
    protected readonly logger: ILogger,
  ) {
    this.logger = logger.withScope('settings.' + section);
  }

  protected get<T>(key: string, defaultValue: T): T {
    const fullKey = \`cph-ng.\${this.section}.\${key}\`;
    const value = workspace.getConfiguration().get<T>(fullKey);
    if (value === undefined) return defaultValue;
    const type = typeof value;
    const defaultType = typeof defaultValue;
    if (type !== defaultType) {
      this.logger.warn(\`Setting \${fullKey} expected \${defaultType}, got \${type}\`);
      return defaultValue;
    }
    this.logger.debug(\`Getting setting\`, { key: fullKey, value, defaultValue });
    return value ?? defaultValue;
  }

  protected set(key: string, value: unknown): Thenable<void> {
    const fullKey = \`cph-ng.\${this.section}.\${key}\`;
    this.logger.debug(\`Setting setting\`, { key: fullKey, value });
    return workspace.getConfiguration().update(fullKey, value, ConfigurationTarget.Global);
  }
}`;

const parseProp = (
  name: string,
  key: string,
  prop: ContributionProps,
): { shortKey: string; type: string; defaultValue: string } => {
  const match = key.match(new RegExp(`^cph-ng\\.${name}\\.([a-zA-Z0-9_]+)$`));
  if (!match) throw new Error(`Invalid property key: ${key}`);
  const shortKey = match[1];

  if (prop.type === 'string') {
    if (typeof prop.default !== 'string') throw new Error(`Expected string default for ${key}`);
    const defaultValue = `'${prop.default}'`;
    if (prop.enum) {
      if (!Array.isArray(prop.enum)) throw new Error(`Expected enum array for ${key}`);
      if (prop.enum.some((e) => typeof e !== 'string'))
        throw new Error(`Expected string enum values for ${key}`);
      return { shortKey, type: prop.enum.map((e) => `'${e}'`).join(' | '), defaultValue };
    }
    return { shortKey, type: 'string', defaultValue };
  }

  if (prop.type === 'number') {
    if (typeof prop.default !== 'number') throw new Error(`Expected number default for ${key}`);
    const defaultValue = prop.default.toString();
    if (prop.enum) {
      if (!Array.isArray(prop.enum)) throw new Error(`Expected enum array for ${key}`);
      if (prop.enum.some((e) => typeof e !== 'number'))
        throw new Error(`Expected number enum values for ${key}`);
      return { shortKey, type: prop.enum.join(' | '), defaultValue };
    }
    return { shortKey, type: 'number', defaultValue };
  }

  if (prop.type === 'boolean') {
    if (typeof prop.default !== 'boolean') throw new Error(`Expected boolean default for ${key}`);
    const defaultValue = prop.default.toString();
    return { shortKey, type: 'boolean', defaultValue };
  }

  if (prop.type === 'array') {
    if (!Array.isArray(prop.default)) throw new Error(`Expected array default for ${key}`);
    if (prop.default.some((e) => typeof e !== 'string'))
      throw new Error(`Expected string array default for ${key}`);
    const defaultValue = `[${prop.default.map((e) => `'${e}'`).join(', ')}]`;
    if (!prop.items) throw new Error(`Expected items definition for array ${key}`);
    if (prop.items.type !== 'string') throw new Error(`Unsupported array item type for ${key}`);
    if (!prop.items.enum) return { shortKey, type: 'string[]', defaultValue };
    if (!Array.isArray(prop.items.enum)) throw new Error(`Expected enum array for ${key}`);
    if (prop.items.enum.some((e) => typeof e !== 'string'))
      throw new Error(`Expected string enum values for ${key}`);
    return {
      shortKey,
      type: `(${prop.items.enum.map((e) => `'${e}'`).join(' | ')})[]`,
      defaultValue,
    };
  }

  throw new Error(`Unsupported property type for ${key}`);
};

const parseSections = (): Section[] => {
  const configs = pkg.contributes.configuration;
  const sections: Section[] = [];
  for (const config of configs) {
    const name = config.id;
    const className = `${name.charAt(0).toUpperCase()}${name.slice(1)}Section`;
    const props = Object.entries(config.properties).map(
      ([key, prop]: [string, ContributionProps]) => ({ key, ...parseProp(name, key, prop) }),
    );
    sections.push({ name, className, props });
  }
  return sections;
};

const generateInterface = (sections: Section[]) => {
  const subInterfaces = sections.map((s) => {
    const props = s.props.map((p) => `  ${p.shortKey}: ${p.type};`).join('\n');
    return `export interface I${s.className} {\n${props}\n}`;
  });

  const mainInterface = [
    `export interface ISettings {`,
    sections.map((s) => `  readonly ${s.name}: I${s.className};`).join('\n'),
    `}`,
  ].join('\n');

  return [header, mainInterface, ...subInterfaces].join('\n\n');
};

const generateAdapter = (sections: Section[]) => {
  const imports = [
    `import { injectable, inject } from 'tsyringe';`,
    `import { ConfigurationTarget, workspace } from 'vscode';`,
    `import { TOKENS } from '@/composition/tokens';`,
    `import type { ILogger } from '@/application/ports/vscode/ILogger';`,
    `import type { `,
    `  ISettings,`,
    ...sections.map(({ className }) => `  I${className},`),
    `} from '@/application/ports/vscode/ISettings';`,
  ].join('\n');

  const sectionClasses = sections.map((s) => {
    const gettersAndSetters = s.props
      .map((p) => {
        return [
          `  get ${p.shortKey}(): ${p.type} {`,
          `    return this.get('${p.shortKey}', ${p.defaultValue});`,
          `  }`,
          `  set ${p.shortKey}(value: ${p.type}) {`,
          `    this.set('${p.shortKey}', value);`,
          `  }`,
        ].join('\n');
      })
      .join('\n\n');

    return [
      `class ${s.className} extends SettingsSectionBase implements I${s.className} {`,
      `  public constructor(logger: ILogger) {`,
      `    super('${s.name}', logger);`,
      `  }`,
      gettersAndSetters,
      `}`,
    ].join('\n');
  });

  const mainAdapter = [
    `@injectable()`,
    `export class SettingsAdapter implements ISettings {`,
    sections.map((s) => `  public readonly ${s.name}: ${s.className};`).join('\n'),
    ``,
    `  public constructor(@inject(TOKENS.logger) logger: ILogger) {`,
    sections.map((s) => `    this.${s.name} = new ${s.className}(logger);`).join('\n'),
    `  }`,
    `}`,
  ].join('\n');

  return [header, imports, AdapterBaseClass, ...sectionClasses, mainAdapter].join('\n\n');
};

const generateMock = (sections: Section[]) => {
  const imports = `import type { ISettings, ${sections.map((s) => `I${s.className}`).join(', ')} } from '@/application/ports/vscode/ISettings';`;

  const mockProps = sections.map((s) => {
    const fields = s.props.map((p) => `    ${p.shortKey}: ${p.defaultValue}`).join(',\n');
    return `  public readonly ${s.name}: I${s.className} = {\n${fields}\n  };`;
  });

  const classDef = [`class SettingsMock implements ISettings {`, mockProps.join('\n\n'), `}`].join(
    '\n',
  );

  return [header, imports, classDef, `export const settingsMock = new SettingsMock();`].join(
    '\n\n',
  );
};

const sections = parseSections();
writeFileSync(Paths.interface, generateInterface(sections));
writeFileSync(Paths.adapter, generateAdapter(sections));
writeFileSync(Paths.mock, generateMock(sections));

console.log('Successfully generated settings files.');
