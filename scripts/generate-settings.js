// Copyright (C) 2025 Langning Chen
// 
// This file is part of cph-ng.
// 
// cph-ng is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// cph-ng is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with cph-ng.  If not, see <https://www.gnu.org/licenses/>.

import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const packageJsonPath = path.join(__dirname, '../package.json');
// 修改生成路径到 infrastructure 目录下
const adapterPath = path.join(__dirname, '../src/infrastructure/vscode/settingsAdapter.ts');
const interfacePath = path.join(__dirname, '../src/application/ports/vscode/ISettings.ts');

const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
const configurations = packageJson.contributes.configuration;

// --- 1. 定义类型转换函数 ---
function getTsType(prop) {
  if (prop.enum) {
    return prop.enum.map((e) => (typeof e === 'string' ? `'${e}'` : e)).join(' | ');
  }
  if (prop.type === 'array') {
    if (prop.items?.type) return `${prop.items.type}[]`;
    if (prop.items?.enum) return `(${prop.items.enum.map((e) => (typeof e === 'string' ? `'${e}'` : e)).join(' | ')})[]`;
    return 'any[]';
  }
  return prop.type || 'any';
}

function formatDefaultValue(val) {
  return val === undefined ? 'undefined' : JSON.stringify(val);
}

// --- 2. 准备数据 ---
const configList = Array.isArray(configurations) ? configurations : [configurations];
const sections = [];

for (const config of configList) {
  const firstKey = Object.keys(config.properties)[0];
  const match = firstKey.match(/^cph-ng\.([^.]+)\./);
  if (!match) continue;

  const sectionName = match[1];
  const className = sectionName.charAt(0).toUpperCase() + sectionName.slice(1) + 'Section';

  const props = Object.entries(config.properties).map(([fullKey, prop]) => ({
    fullKey,
    shortKey: fullKey.split('.').pop(),
    type: getTsType(prop),
    defaultValue: formatDefaultValue(prop.default)
  }));

  sections.push({ name: sectionName, className, props });
}

// --- 3. 生成 ISettings.ts (接口文件) ---
let interfaceContent = `// THIS FILE IS AUTO-GENERATED
// DO NOT EDIT THIS FILE MANUALLY

export interface ISettings {
${sections.map(s => `  readonly ${s.name}: I${s.className};`).join('\n')}
}

`;

for (const section of sections) {
  interfaceContent += `export interface I${section.className} {
${section.props.map(p => `  ${p.shortKey}: ${p.type};`).join('\n')}
}\n\n`;
}
fs.writeFileSync(interfacePath, interfaceContent);

// --- 4. 生成 settingsAdapter.ts (实现文件) ---
let adapterContent = `// THIS FILE IS AUTO-GENERATED
// DO NOT EDIT THIS FILE MANUALLY

import { injectable, inject } from 'tsyringe';
import { ConfigurationTarget, workspace } from 'vscode';
import { renderPath } from '@/utils/strTemplate';
import { TOKENS } from '@/composition/tokens';
import type { ILogger } from '@/application/ports/vscode/ILogger';
import type { ISettings, ${sections.map(s => `I${s.className}`).join(', ')} } from '@/application/ports/vscode/ISettings';

class SettingsSectionBase {
  protected logger: ILogger;
  constructor(protected sectionName: string, logger: ILogger) {
    this.logger = logger.withScope('settings.' + sectionName);
  }

  protected get<T>(key: string, defaultValue: T): T {
    const fullKey = \`cph-ng.\${this.sectionName}.\${key}\`;
    const value = workspace.getConfiguration().get<T>(fullKey);
    
    if (value === undefined) return defaultValue;

    const expectedType = typeof defaultValue;
    if (expectedType !== 'undefined' && value !== null && typeof value !== expectedType) {
        this.logger.warn(\`Setting \${fullKey} invalid type. Expected \${expectedType}, got \${typeof value}\`);
        return defaultValue;
    }

    return value ?? defaultValue;
  }

  protected set(key: string, value: unknown): Thenable<void> {
    return workspace
      .getConfiguration()
      .update(\`cph-ng.\${this.sectionName}.\${key}\`, value, ConfigurationTarget.Global);
  }
}
`;

for (const section of sections) {
  adapterContent += `
class ${section.className} extends SettingsSectionBase implements I${section.className} {
  constructor(logger: ILogger) {
    super('${section.name}', logger);
  }
`;

  for (const prop of section.props) {
    // 特殊逻辑处理
    if (prop.fullKey === 'cph-ng.cache.directory') {
      adapterContent += `  get ${prop.shortKey}(): ${prop.type} {
    return renderPath(this.get('${prop.shortKey}', ${prop.defaultValue}));
  }\n`;
    } else {
      adapterContent += `  get ${prop.shortKey}(): ${prop.type} {
    return this.get('${prop.shortKey}', ${prop.defaultValue});
  }\n`;
    }

    // Setter 处理
    adapterContent += `  set ${prop.shortKey}(value: ${prop.type}) {
    this.set('${prop.shortKey}', value);
  }\n`;
  }
  adapterContent += `}\n`;
}

adapterContent += `
@injectable()
export class SettingsAdapter implements ISettings {
${sections.map(s => `  public readonly ${s.name}: ${s.className};`).join('\n')}

  constructor(@inject(TOKENS.Logger) logger: ILogger) {
${sections.map(s => `    this.${s.name} = new ${s.className}(logger);`).join('\n')}
  }
}
`;

fs.writeFileSync(adapterPath, adapterContent);

console.log(`Successfully generated:
- ${interfacePath}
- ${adapterPath}`);
