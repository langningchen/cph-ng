// Copyright (C) 2026 Langning Chen
//
// This file is part of cph-ng.
//
// cph-ng is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// cph-ng is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with cph-ng.  If not, see <https://www.gnu.org/licenses/>.

import { readFileSync, writeFileSync } from 'node:fs';

const PATHS = {
  adapter: 'src/infrastructure/vscode/settingsAdapter.ts',
  interface: 'src/application/ports/vscode/ISettings.ts',
  mock: 'tests/infrastructure/vscode/settingsMock.ts',
  packageJson: 'package.json',
};

const header = [
  `// THIS FILE IS AUTO-GENERATED BY scripts/generate-settings.js`,
  `// DO NOT EDIT THIS FILE MANUALLY`,
].join('\n');

const ADAPTER_BASE_CLASS = `
class SettingsSectionBase {
  protected logger: ILogger;
  constructor(protected sectionName: string, logger: ILogger) {
    this.logger = logger.withScope('settings.' + sectionName);
  }

  protected get<T>(key: string, defaultValue: T): T {
    const fullKey = \`cph-ng.\${this.sectionName}.\${key}\`;
    const value = workspace.getConfiguration().get<T>(fullKey);
    
    if (value === undefined) return defaultValue;

    const expectedType = typeof defaultValue;
    if (expectedType !== 'undefined' && value !== null && typeof value !== expectedType) {
        this.logger.warn(\`Setting \${fullKey} invalid type. Expected \${expectedType}, got \${typeof value}\`);
        return defaultValue;
    }

    return value ?? defaultValue;
  }

  protected set(key: string, value: unknown): Thenable<void> {
    return workspace
      .getConfiguration()
      .update(\`cph-ng.\${this.sectionName}.\${key}\`, value, ConfigurationTarget.Global);
  }
}
`;

const getTsType = (prop) => {
  if (prop.enum) {
    return prop.enum.map((e) => (typeof e === 'string' ? `'${e}'` : e)).join(' | ');
  }
  if (prop.type === 'array') {
    if (prop.items?.type) return `${prop.items.type}[]`;
    if (prop.items?.enum) {
      const enumType = prop.items.enum
        .map((e) => (typeof e === 'string' ? `'${e}'` : e))
        .join(' | ');
      return `(${enumType})[]`;
    }
    return 'any[]';
  }
  return prop.type || 'any';
};

const formatDefaultValue = (val) => (val === undefined ? 'undefined' : JSON.stringify(val));

function parseSections() {
  const packageJson = JSON.parse(readFileSync(PATHS.packageJson, 'utf8'));
  const configs = packageJson.contributes.configuration;
  const sections = [];

  for (const config of configs) {
    const firstKey = Object.keys(config.properties)[0];
    const match = firstKey.match(/^cph-ng\.([^.]+)\./);
    if (!match) continue;

    const sectionName = match[1];
    const className = `${sectionName.charAt(0).toUpperCase()}${sectionName.slice(1)}Section`;

    const props = Object.entries(config.properties).map(([fullKey, prop]) => ({
      fullKey,
      shortKey: fullKey.split('.').pop(),
      type: getTsType(prop),
      defaultValue: formatDefaultValue(prop.default),
    }));

    sections.push({ name: sectionName, className, props });
  }
  return sections;
}

function generateInterface(sections) {
  const subInterfaces = sections.map((s) => {
    const props = s.props.map((p) => `  ${p.shortKey}: ${p.type};`).join('\n');
    return `export interface I${s.className} {\n${props}\n}`;
  });

  const mainInterface = [
    `export interface ISettings {`,
    sections.map((s) => `  readonly ${s.name}: I${s.className};`).join('\n'),
    `}`,
  ].join('\n');

  return [header, mainInterface, ...subInterfaces].join('\n\n');
}

function generateAdapter(sections) {
  const imports = [
    `import { injectable, inject } from 'tsyringe';`,
    `import { ConfigurationTarget, workspace } from 'vscode';`,
    `import { renderPath } from '@/utils/strTemplate';`,
    `import { TOKENS } from '@/composition/tokens';`,
    `import type { ILogger } from '@/application/ports/vscode/ILogger';`,
    `import type { ISettings, ${sections.map((s) => `I${s.className}`).join(', ')} } from '@/application/ports/vscode/ISettings';`,
  ].join('\n');

  const sectionClasses = sections.map((s) => {
    const gettersAndSetters = s.props
      .map((p) => {
        return [
          `  get ${p.shortKey}(): ${p.type} {`,
          `    return this.get('${p.shortKey}', ${p.defaultValue});`,
          `  }`,
          `  set ${p.shortKey}(value: ${p.type}) {`,
          `    this.set('${p.shortKey}', value);`,
          `  }`,
        ].join('\n');
      })
      .join('\n\n');

    return [
      `class ${s.className} extends SettingsSectionBase implements I${s.className} {`,
      `  constructor(logger: ILogger) {`,
      `    super('${s.name}', logger);`,
      `  }`,
      gettersAndSetters,
      `}`,
    ].join('\n');
  });

  const mainAdapter = [
    `@injectable()`,
    `export class SettingsAdapter implements ISettings {`,
    sections.map((s) => `  public readonly ${s.name}: ${s.className};`).join('\n'),
    ``,
    `  constructor(@inject(TOKENS.Logger) logger: ILogger) {`,
    sections.map((s) => `    this.${s.name} = new ${s.className}(logger);`).join('\n'),
    `  }`,
    `}`,
  ].join('\n');

  return [header, imports, ADAPTER_BASE_CLASS, ...sectionClasses, mainAdapter].join('\n\n');
}

function generateMock(sections) {
  const imports = `import type { ISettings, ${sections.map((s) => `I${s.className}`).join(', ')} } from '@/application/ports/vscode/ISettings';`;

  const mockProps = sections.map((s) => {
    const fields = s.props.map((p) => `    ${p.shortKey}: ${p.defaultValue}`).join(',\n');
    return `  public readonly ${s.name}: I${s.className} = {\n${fields}\n  };`;
  });

  const classDef = [`class SettingsMock implements ISettings {`, mockProps.join('\n\n'), `}`].join(
    '\n',
  );

  return [header, imports, classDef, `export const settingsMock = new SettingsMock();`].join(
    '\n\n',
  );
}

const sections = parseSections();

writeFileSync(PATHS.interface, generateInterface(sections));
writeFileSync(PATHS.adapter, generateAdapter(sections));
writeFileSync(PATHS.mock, generateMock(sections));

console.log('Successfully generated settings files.');
